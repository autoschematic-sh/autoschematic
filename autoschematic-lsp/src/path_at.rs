use anyhow::{bail, Context, Result};
use codespan_reporting::files::{Files, SimpleFile};
use itertools::Itertools;
use pest::{iterators::Pair, Parser, Span};

use crate::parser::{RonParser, Rule};     // generated by #[derive(Parser)]

#[derive(Debug, Clone)]
pub enum Component {
    Name(String),
    Index(usize),
}

pub fn path_at(src: &str, line: usize, col: usize) -> Result<Vec<Component>> {
    // 1) map (line, col) → byte offset
    let file = SimpleFile::new("input", src);
    
    // let line_start = file.line_number(id, line_index)
    let offset = file.location_to_byte_index(line - 1, col - 1)
        .with_context(|| format!("line {line}, column {col} is out of bounds"))?;

    // 2) parse
    let mut pairs = RonParser::parse(Rule::ron, src)?;
    let root = pairs.next().unwrap();          // SOI … EOI

    // 3) walk the tree to the innermost node that covers `offset`
    let mut trail = Vec::<Component>::new();
    descend(root, offset, src, &mut trail)?;

    Ok(trail)
}

/*───────────────────────────────────────────────────────────────────────────*/

/// Recursive descent that collects a breadcrumb whenever the rule has a
/// semantic meaning (field name, map key, index, …).
fn descend(pair: Pair<Rule>,
           cursor: usize,
           src: &str,
           trail: &mut Vec<Component>) -> Result<bool> {
    let span = pair.as_span();
    if !covers(span, cursor) {
        return Ok(false);          // cursor not inside this node
    }

    match pair.as_rule() {
        // -- outermost “ron” rule is ignored
        Rule::ron | Rule::value => {
            for child in pair.into_inner() {
                if descend(child, cursor, src, trail)? {
                    break;
                }
            }
        }

        /*──────────────── structs ───────────────*/
        Rule::named_struct | Rule::tuple_struct | Rule::unit_struct => {
            // first inner child may be an ident
            let mut it = pair.clone().into_inner();
            if let Some(id_pair) = it.next_if(|p| p.as_rule() == Rule::ident) {
                if covers(id_pair.as_span(), cursor) {
                    trail.push(Component::Name(slice(src, id_pair.as_span())));
                }
            }
            // continue through the rest
            for child in it {
                if descend(child, cursor, src, trail)? { break; }
            }
        }

        Rule::named_field => {
            //  ident ":" value
            let mut inner = pair.clone().into_inner();
            let name = inner.next().unwrap();   // ident
            let val  = inner.next().unwrap();   // value
            trail.push(Component::Name(slice(src, name.as_span())));
            descend(val, cursor, src, trail)?;
        }

        /*──────────────── lists / tuples ─────────*/
        Rule::list | Rule::tuple => {
            for (idx, val) in pair.into_inner()
                                   .filter(|p| p.as_rule() == Rule::value)
                                   .enumerate() {
                if descend(val, cursor, src, trail)? {
                    trail.push(Component::Index(idx));
                    break;
                }
            }
        }

        /*──────────────── maps ───────────────────*/
        Rule::map => {
            for entry in pair.into_inner() {            // map_entry
                let mut it = entry.into_inner();
                let key = it.next().unwrap();
                let val = it.next().unwrap();
                if descend(key.clone(), cursor, src, trail)? {
                    // Cursor is inside the key itself → report previous trail
                    break;
                }
                if descend(val, cursor, src, trail)? {
                    // Cursor somewhere in the value → emit key string
                    let key_str = match key.as_rule() {
                        Rule::string_std | Rule::string_raw => unquote_string(src, key.as_span()),
                        _ => slice(src, key.as_span()),
                    };
                    trail.push(Component::Name(key_str));
                    break;
                }
            }
        }

        /*──────────────── enum variants ──────────*/
        Rule::enum_variant_named | Rule::enum_variant_tuple | Rule::enum_variant_unit => {
            let mut it = pair.clone().into_inner();
            let variant_name = it.next().unwrap();          // ident
            if covers(variant_name.as_span(), cursor) {
                trail.push(Component::Name(slice(src, variant_name.as_span())));
                return Ok(true);
            }
            // else step into payload
            for child in it {
                if descend(child, cursor, src, trail)? {
                    trail.push(Component::Name(slice(src, variant_name.as_span())));
                    break;
                }
            }
        }

        /*──────────────── leaf cases we ignore ───*/
        _ => {
            // dive blindly; if any child returns true we stop
            for child in pair.clone().into_inner() {
                if descend(child, cursor, src, trail)? {
                    return Ok(true);
                }
            }
        }
    }

    Ok(true)
}

/*──────────────── helpers ─────────────────────────────────────────────────*/

#[inline] fn covers(span: Span, pos: usize) -> bool {
    let (lo, hi) = (span.start(), span.end());
    lo <= pos && pos < hi
}

#[inline] fn slice<'s>(src: &'s str, span: Span<'s>) -> String {
    src[span.start()..span.end()].to_owned()
}

/// Rudimentary `"` or `r#"..."#` stripper so map keys render nicely
fn unquote_string(src: &str, span: Span) -> String {
    let txt = &src[span.start()..span.end()];
    let first_quote = txt.find('"').unwrap();
    let last_quote  = txt.rfind('"').unwrap();
    txt[first_quote + 1 .. last_quote].to_owned()
}