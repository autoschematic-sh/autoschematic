use anyhow::Result;
use autoschematic_core::connector::DocIdent;
use pest::{Parser, Span, iterators::Pair};

use crate::{
    parse::{RonParser, Rule},
    util::pos_byte_index,
}; // generated by #[derive(Parser)]

#[derive(Debug, Clone)]
pub enum Component {
    Name(String),
    Index(usize),
}

pub fn path_at(src: &str, line: usize, col: usize) -> Result<Option<Vec<Component>>> {
    // 1) map (line, col) → byte offset
    // let file = SimpleFile::new("input", src);
    //

    // let line_start = file.line_number(id, line_index)
    // let offset = file
    //     .location_to_byte_index(line - 1, col - 1)
    //     .with_context(|| format!("line {line}, column {col} is out of bounds"))?;
    let Some(byte_index) = pos_byte_index(line, col, src) else {
        return Ok(None);
    };

    // 2) parse
    let mut pairs = RonParser::parse(Rule::ron, src)?;
    let root = pairs.next().unwrap(); // SOI … EOI

    // 3) walk the tree to the innermost node that covers `offset`
    let mut trail = Vec::<Component>::new();
    descend(root, byte_index, src, &mut trail)?;

    Ok(Some(trail))
}

pub fn ident_at(src: &str, line: usize, col: usize) -> Result<Option<DocIdent>> {
    // 1) map (line, col) → byte offset
    // let file = SimpleFile::new("input", src);
    //

    // let line_start = file.line_number(id, line_index)
    // let offset = file
    //     .location_to_byte_index(line - 1, col - 1)
    //     .with_context(|| format!("line {line}, column {col} is out of bounds"))?;
    let Some(byte_index) = pos_byte_index(line, col, src) else {
        return Ok(None);
    };

    // 2) parse
    let mut pairs = RonParser::parse(Rule::ron, src)?;
    let root = pairs.next().unwrap(); // SOI … EOI

    // 3) walk the tree to the innermost node that covers `offset`
    let mut ident = None;
    let mut parent = None;
    descend_find_docident(root, byte_index, src, &mut parent, &mut ident)?;

    Ok(ident)
}

/// recursive descent parser to find the ident and parent, if any, at the cursor position.
fn descend_find_docident(
    pair: Pair<Rule>,
    cursor: usize,
    _src: &str,
    parent: &mut Option<DocIdent>,
    ident: &mut Option<DocIdent>,
) -> Result<bool> {
    let span = pair.as_span();
    if !covers(span, cursor) {
        // eprintln!("cursor not inside this node");
        return Ok(false);
    }

    match pair.as_rule() {
        // -- outermost “ron” rule is ignored
        Rule::ron | Rule::value => {
            for child in pair.into_inner() {
                if descend_find_docident(child, cursor, _src, parent, ident)? {
                    break;
                }
            }
        }

        // structs
        Rule::named_struct | Rule::tuple_struct | Rule::unit_struct => {
            // first inner child may be an ident
            let mut it = pair.clone().into_inner();
            // eprintln!("it: {}", it);
            if let Some(id_pair) = it.next()
                && id_pair.as_rule() == Rule::ident
            {
                if covers(id_pair.as_span(), cursor) {
                    *ident = Some(DocIdent::Struct {
                        name: id_pair.as_str().into(),
                    })
                }
                if covers(pair.as_span(), cursor) {
                    *parent = Some(DocIdent::Struct {
                        name: id_pair.as_str().into(),
                    })
                }
            }

            // if let Some(id_pair) = it.next_if(|p| p.as_rule() == Rule::ident) {
            //     if covers(id_pair.as_span(), cursor) {
            //         trail.push(Component::Name(slice(src, id_pair.as_span())));
            //     }
            // }
            // continue through the rest
            for child in it {
                if descend_find_docident(child, cursor, _src, parent, ident)? {
                    break;
                }
            }
        }

        Rule::named_field => {
            //  ident ":" value
            let mut inner = pair.clone().into_inner();
            let name = inner.next().unwrap(); // ident
            // let val = inner.next().unwrap(); // value
            // trail.push(Component::Name(slice(src, name.as_span())));
            // descend(val, cursor, src, trail)?;
            if name.as_rule() == Rule::ident {
                if covers(name.as_span(), cursor)
                    && let Some(DocIdent::Struct { name: struct_name }) = parent
                {
                    *ident = Some(DocIdent::Field {
                        parent: struct_name.to_string(),
                        name: name.as_str().into(),
                    })
                }
                // trail.push(Component::Name(slice(src, id_pair.as_span())));

                for child in inner {
                    // eprintln!("child: {}", child.as_str());
                    if descend_find_docident(child, cursor, _src, parent, ident)? {
                        // trail.push(Component::Index(idx));
                        break;
                    }
                }
            }
        }

        // lists / tuples
        Rule::list | Rule::tuple => {
            for val in pair.into_inner().filter(|p| p.as_rule() == Rule::value) {
                if descend_find_docident(val, cursor, _src, parent, ident)? {
                    // trail.push(Component::Index(idx));
                    break;
                }
            }
        }

        // maps
        Rule::map => {
            for entry in pair.into_inner() {
                // map_entry
                let mut it = entry.into_inner();
                let key = it.next().unwrap();
                let val = it.next().unwrap();
                if descend_find_docident(key.clone(), cursor, _src, parent, ident)? {
                    // Cursor is inside the key itself: report previous trail
                    break;
                }
                if descend_find_docident(val, cursor, _src, parent, ident)? {
                    // Cursor somewhere in the value: emit key string
                    // let key_str = match key.as_rule() {
                    //     Rule::string_std | Rule::string_raw => unquote_string(src, key.as_span()),
                    //     _ => slice(src, key.as_span()),
                    // };
                    // trail.push(Component::Name(key_str));
                    break;
                }
            }
        }

        // enum variants
        Rule::enum_variant_named | Rule::enum_variant_tuple | Rule::enum_variant_unit => {
            let mut it = pair.clone().into_inner();
            let variant_name = it.next().unwrap(); // ident
            if covers(variant_name.as_span(), cursor) {
                // trail.push(Component::Name(slice(src, variant_name.as_span())));
                return Ok(true);
            }
            // else step into payload
            for child in it {
                if descend_find_docident(child, cursor, _src, parent, ident)? {
                    // trail.push(Component::Name(slice(src, variant_name.as_span())));
                    break;
                }
            }
        }

        // leaf cases we ignore
        _ => {
            // dive blindly; if any child returns true we stop
            for child in pair.clone().into_inner() {
                if descend_find_docident(child, cursor, _src, parent, ident)? {
                    return Ok(true);
                }
            }
        }
    }

    Ok(true)
}

/// Recursive descent that collects a breadcrumb whenever the rule has a
/// semantic meaning (field name, map key, index, …).
fn descend(pair: Pair<Rule>, cursor: usize, src: &str, trail: &mut Vec<Component>) -> Result<bool> {
    let span = pair.as_span();
    if !covers(span, cursor) {
        return Ok(false);
    }

    match pair.as_rule() {
        // outermost “ron” rule is ignored
        Rule::ron | Rule::value => {
            for child in pair.into_inner() {
                if descend(child, cursor, src, trail)? {
                    break;
                }
            }
        }

        // structs
        Rule::named_struct | Rule::tuple_struct | Rule::unit_struct => {
            // first inner child may be an ident
            let mut it = pair.clone().into_inner();
            if let Some(id_pair) = it.next()
                && id_pair.as_rule() == Rule::ident
            {
                // if covers(id_pair.as_span(), cursor) {
                trail.push(Component::Name(slice(src, id_pair.as_span())));
                // }
            }

            // if let Some(id_pair) = it.next_if(|p| p.as_rule() == Rule::ident) {
            //     if covers(id_pair.as_span(), cursor) {
            //         trail.push(Component::Name(slice(src, id_pair.as_span())));
            //     }
            // }
            // continue through the rest
            for child in it {
                if descend(child, cursor, src, trail)? {
                    break;
                }
            }
        }

        Rule::named_field => {
            //  ident ":" value
            let mut inner = pair.clone().into_inner();
            let name = inner.next().unwrap(); // ident
            let val = inner.next().unwrap(); // value
            trail.push(Component::Name(slice(src, name.as_span())));
            descend(val, cursor, src, trail)?;
        }

        // lists / tuples
        Rule::list | Rule::tuple => {
            for (idx, val) in pair.into_inner().filter(|p| p.as_rule() == Rule::value).enumerate() {
                if descend(val, cursor, src, trail)? {
                    trail.push(Component::Index(idx));
                    break;
                }
            }
        }

        // maps
        Rule::map => {
            for entry in pair.into_inner() {
                // map_entry
                let mut it = entry.into_inner();
                let key = it.next().unwrap();
                let val = it.next().unwrap();
                if descend(key.clone(), cursor, src, trail)? {
                    // Cursor is inside the key itself -> report previous trail
                    break;
                }
                if descend(val, cursor, src, trail)? {
                    // Cursor somewhere in the value -> emit key string
                    // let key_str = match key.as_rule() {
                    //     Rule::string_std | Rule::string_raw => unquote_string(src, key.as_span()),
                    //     _ => slice(src, key.as_span()),
                    // };
                    // trail.push(Component::Name(key_str));
                    break;
                }
            }
        }

        // enum variants
        Rule::enum_variant_named | Rule::enum_variant_tuple | Rule::enum_variant_unit => {
            let mut it = pair.clone().into_inner();
            let variant_name = it.next().unwrap(); // ident
            if covers(variant_name.as_span(), cursor) {
                trail.push(Component::Name(slice(src, variant_name.as_span())));
                return Ok(true);
            }
            // else step into payload
            for child in it {
                if descend(child, cursor, src, trail)? {
                    trail.push(Component::Name(slice(src, variant_name.as_span())));
                    break;
                }
            }
        }

        // leaf cases we ignore
        _ => {
            // dive blindly; if any child returns true we stop
            for child in pair.clone().into_inner() {
                if descend(child, cursor, src, trail)? {
                    return Ok(true);
                }
            }
        }
    }

    Ok(true)
}

fn covers(span: Span, pos: usize) -> bool {
    let (lo, hi) = (span.start(), span.end());
    lo <= pos && pos < hi
}

fn slice<'s>(src: &'s str, span: Span<'s>) -> String {
    src[span.start()..span.end()].to_owned()
}

// Rudimentary `"` or `r#"..."#` stripper so map keys render nicely
// fn unquote_string(src: &str, span: Span) -> String {
//     let txt = &src[span.start()..span.end()];
//     let first_quote = txt.find('"').unwrap();
//     let last_quote = txt.rfind('"').unwrap();
//     txt[first_quote + 1..last_quote].to_owned()
// }
