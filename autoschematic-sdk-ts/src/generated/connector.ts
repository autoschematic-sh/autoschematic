// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.19.6
// source: connector.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "connector";

export enum FilterOutputType {
  CONFIG = 0,
  RESOURCE = 1,
  BUNDLE = 2,
  NONE = 3,
  UNRECOGNIZED = -1,
}

export function filterOutputTypeFromJSON(object: any): FilterOutputType {
  switch (object) {
    case 0:
    case "CONFIG":
      return FilterOutputType.CONFIG;
    case 1:
    case "RESOURCE":
      return FilterOutputType.RESOURCE;
    case 2:
    case "BUNDLE":
      return FilterOutputType.BUNDLE;
    case 3:
    case "NONE":
      return FilterOutputType.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilterOutputType.UNRECOGNIZED;
  }
}

export function filterOutputTypeToJSON(object: FilterOutputType): string {
  switch (object) {
    case FilterOutputType.CONFIG:
      return "CONFIG";
    case FilterOutputType.RESOURCE:
      return "RESOURCE";
    case FilterOutputType.BUNDLE:
      return "BUNDLE";
    case FilterOutputType.NONE:
      return "NONE";
    case FilterOutputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / A generic empty message (was google.protobuf.Empty) */
export interface Empty {
}

/** / --- Filter --- */
export interface FilterRequest {
  addr: string;
}

export interface FilterResponse {
  filter: FilterOutputType;
}

/** / --- Listing --- */
export interface ListRequest {
  subpath: string;
}

export interface ListResponse {
  addrs: string[];
}

/** / --- Get resource --- */
export interface GetRequest {
  addr: string;
}

export interface GetResponse {
  /** / false ⇒ no resource at `addr`; other fields ignored */
  exists: boolean;
  resourceDefinition: Uint8Array;
  outputs: { [key: string]: string };
}

export interface GetResponse_OutputsEntry {
  key: string;
  value: string;
}

/** / --- Plan --- */
export interface PlanRequest {
  addr: string;
  /** empty means “none” */
  current: Uint8Array;
  /** empty means “none” */
  desired: Uint8Array;
}

export interface OpPlanOutput {
  opDefinition: string;
  writesOutputs: string[];
  friendlyMessage: string;
}

export interface PlanResponse {
  ops: OpPlanOutput[];
}

/** / --- Execute an op --- */
export interface OpExecRequest {
  addr: string;
  op: string;
}

export interface OpExecResponse {
  /** missing or empty ⇒ none */
  outputs: { [key: string]: string };
  friendlyMessage: string;
}

export interface OpExecResponse_OutputsEntry {
  key: string;
  value: string;
}

/** / --- Address translation --- */
export interface AddrRequest {
  addr: string;
}

export interface AddrPhyToVirtResponse {
  hasVirt: boolean;
  virtAddr: string;
}

/** / --- Subpaths (parallelism hints) --- */
export interface SubpathsResponse {
  subpaths: string[];
}

/** / --- Skeletons (templates) --- */
export interface SkeletonOutput {
  addr: string;
  body: Uint8Array;
}

export interface GetSkeletonsResponse {
  skeletons: SkeletonOutput[];
}

/** / --- Docstrings --- */
export interface StructIdent {
  name: string;
}

export interface FieldIdent {
  parent: string;
  name: string;
}

export interface DocIdent {
  struct?: StructIdent | undefined;
  field?: FieldIdent | undefined;
}

export interface GetDocRequest {
  addr: string;
  ident: DocIdent | undefined;
}

export interface GetDocResponse {
  hasDoc: boolean;
  markdown: string;
}

/** / --- Equality check --- */
export interface EqRequest {
  addr: string;
  a: Uint8Array;
  b: Uint8Array;
}

export interface EqResponse {
  equal: boolean;
}

/** / --- Diagnostics --- */
export interface DiagnosticPosition {
  line: number;
  col: number;
}

export interface DiagnosticSpan {
  start: DiagnosticPosition | undefined;
  end: DiagnosticPosition | undefined;
}

export interface Diagnostic {
  severity: number;
  span: DiagnosticSpan | undefined;
  message: string;
}

export interface DiagnosticOutput {
  diagnostics: Diagnostic[];
}

export interface DiagRequest {
  addr: string;
  a: Uint8Array;
}

export interface DiagResponse {
  diagnostics: DiagnosticOutput | undefined;
}

/** / --- Virt‐to‐phy mapping --- */
export interface ReadOutput {
  addr: string;
  key: string;
}

export interface Deferred {
  reads: ReadOutput[];
}

export interface Path {
  path: string;
}

export interface VirtToPhyOutput {
  notPresent?: Empty | undefined;
  deferred?: Deferred | undefined;
  present?: Path | undefined;
  null?: Path | undefined;
}

/** / --- Unbundle bundles into resources --- */
export interface UnbundleRequest {
  addr: string;
  bundle: Uint8Array;
}

export interface BundleOutput {
  filename: string;
  fileContents: string;
}

export interface UnbundleResponse {
  bundles: BundleOutput[];
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseFilterRequest(): FilterRequest {
  return { addr: "" };
}

export const FilterRequest: MessageFns<FilterRequest> = {
  encode(message: FilterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterRequest {
    return { addr: isSet(object.addr) ? globalThis.String(object.addr) : "" };
  },

  toJSON(message: FilterRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterRequest>, I>>(base?: I): FilterRequest {
    return FilterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterRequest>, I>>(object: I): FilterRequest {
    const message = createBaseFilterRequest();
    message.addr = object.addr ?? "";
    return message;
  },
};

function createBaseFilterResponse(): FilterResponse {
  return { filter: 0 };
}

export const FilterResponse: MessageFns<FilterResponse> = {
  encode(message: FilterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== 0) {
      writer.uint32(8).int32(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.filter = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterResponse {
    return { filter: isSet(object.filter) ? filterOutputTypeFromJSON(object.filter) : 0 };
  },

  toJSON(message: FilterResponse): unknown {
    const obj: any = {};
    if (message.filter !== 0) {
      obj.filter = filterOutputTypeToJSON(message.filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterResponse>, I>>(base?: I): FilterResponse {
    return FilterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterResponse>, I>>(object: I): FilterResponse {
    const message = createBaseFilterResponse();
    message.filter = object.filter ?? 0;
    return message;
  },
};

function createBaseListRequest(): ListRequest {
  return { subpath: "" };
}

export const ListRequest: MessageFns<ListRequest> = {
  encode(message: ListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subpath !== "") {
      writer.uint32(10).string(message.subpath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subpath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRequest {
    return { subpath: isSet(object.subpath) ? globalThis.String(object.subpath) : "" };
  },

  toJSON(message: ListRequest): unknown {
    const obj: any = {};
    if (message.subpath !== "") {
      obj.subpath = message.subpath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRequest>, I>>(base?: I): ListRequest {
    return ListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRequest>, I>>(object: I): ListRequest {
    const message = createBaseListRequest();
    message.subpath = object.subpath ?? "";
    return message;
  },
};

function createBaseListResponse(): ListResponse {
  return { addrs: [] };
}

export const ListResponse: MessageFns<ListResponse> = {
  encode(message: ListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addrs) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addrs.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListResponse {
    return { addrs: globalThis.Array.isArray(object?.addrs) ? object.addrs.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ListResponse): unknown {
    const obj: any = {};
    if (message.addrs?.length) {
      obj.addrs = message.addrs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListResponse>, I>>(base?: I): ListResponse {
    return ListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListResponse>, I>>(object: I): ListResponse {
    const message = createBaseListResponse();
    message.addrs = object.addrs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRequest(): GetRequest {
  return { addr: "" };
}

export const GetRequest: MessageFns<GetRequest> = {
  encode(message: GetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequest {
    return { addr: isSet(object.addr) ? globalThis.String(object.addr) : "" };
  },

  toJSON(message: GetRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRequest>, I>>(base?: I): GetRequest {
    return GetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRequest>, I>>(object: I): GetRequest {
    const message = createBaseGetRequest();
    message.addr = object.addr ?? "";
    return message;
  },
};

function createBaseGetResponse(): GetResponse {
  return { exists: false, resourceDefinition: new Uint8Array(0), outputs: {} };
}

export const GetResponse: MessageFns<GetResponse> = {
  encode(message: GetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    if (message.resourceDefinition.length !== 0) {
      writer.uint32(18).bytes(message.resourceDefinition);
    }
    Object.entries(message.outputs).forEach(([key, value]) => {
      GetResponse_OutputsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceDefinition = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = GetResponse_OutputsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.outputs[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponse {
    return {
      exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false,
      resourceDefinition: isSet(object.resourceDefinition)
        ? bytesFromBase64(object.resourceDefinition)
        : new Uint8Array(0),
      outputs: isObject(object.outputs)
        ? Object.entries(object.outputs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetResponse): unknown {
    const obj: any = {};
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    if (message.resourceDefinition.length !== 0) {
      obj.resourceDefinition = base64FromBytes(message.resourceDefinition);
    }
    if (message.outputs) {
      const entries = Object.entries(message.outputs);
      if (entries.length > 0) {
        obj.outputs = {};
        entries.forEach(([k, v]) => {
          obj.outputs[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse>, I>>(base?: I): GetResponse {
    return GetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse>, I>>(object: I): GetResponse {
    const message = createBaseGetResponse();
    message.exists = object.exists ?? false;
    message.resourceDefinition = object.resourceDefinition ?? new Uint8Array(0);
    message.outputs = Object.entries(object.outputs ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetResponse_OutputsEntry(): GetResponse_OutputsEntry {
  return { key: "", value: "" };
}

export const GetResponse_OutputsEntry: MessageFns<GetResponse_OutputsEntry> = {
  encode(message: GetResponse_OutputsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResponse_OutputsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResponse_OutputsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetResponse_OutputsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetResponse_OutputsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetResponse_OutputsEntry>, I>>(base?: I): GetResponse_OutputsEntry {
    return GetResponse_OutputsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetResponse_OutputsEntry>, I>>(object: I): GetResponse_OutputsEntry {
    const message = createBaseGetResponse_OutputsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePlanRequest(): PlanRequest {
  return { addr: "", current: new Uint8Array(0), desired: new Uint8Array(0) };
}

export const PlanRequest: MessageFns<PlanRequest> = {
  encode(message: PlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.current.length !== 0) {
      writer.uint32(18).bytes(message.current);
    }
    if (message.desired.length !== 0) {
      writer.uint32(26).bytes(message.desired);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.current = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.desired = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlanRequest {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      current: isSet(object.current) ? bytesFromBase64(object.current) : new Uint8Array(0),
      desired: isSet(object.desired) ? bytesFromBase64(object.desired) : new Uint8Array(0),
    };
  },

  toJSON(message: PlanRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.current.length !== 0) {
      obj.current = base64FromBytes(message.current);
    }
    if (message.desired.length !== 0) {
      obj.desired = base64FromBytes(message.desired);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlanRequest>, I>>(base?: I): PlanRequest {
    return PlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlanRequest>, I>>(object: I): PlanRequest {
    const message = createBasePlanRequest();
    message.addr = object.addr ?? "";
    message.current = object.current ?? new Uint8Array(0);
    message.desired = object.desired ?? new Uint8Array(0);
    return message;
  },
};

function createBaseOpPlanOutput(): OpPlanOutput {
  return { opDefinition: "", writesOutputs: [], friendlyMessage: "" };
}

export const OpPlanOutput: MessageFns<OpPlanOutput> = {
  encode(message: OpPlanOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opDefinition !== "") {
      writer.uint32(10).string(message.opDefinition);
    }
    for (const v of message.writesOutputs) {
      writer.uint32(18).string(v!);
    }
    if (message.friendlyMessage !== "") {
      writer.uint32(26).string(message.friendlyMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpPlanOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpPlanOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.opDefinition = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.writesOutputs.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.friendlyMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpPlanOutput {
    return {
      opDefinition: isSet(object.opDefinition) ? globalThis.String(object.opDefinition) : "",
      writesOutputs: globalThis.Array.isArray(object?.writesOutputs)
        ? object.writesOutputs.map((e: any) => globalThis.String(e))
        : [],
      friendlyMessage: isSet(object.friendlyMessage) ? globalThis.String(object.friendlyMessage) : "",
    };
  },

  toJSON(message: OpPlanOutput): unknown {
    const obj: any = {};
    if (message.opDefinition !== "") {
      obj.opDefinition = message.opDefinition;
    }
    if (message.writesOutputs?.length) {
      obj.writesOutputs = message.writesOutputs;
    }
    if (message.friendlyMessage !== "") {
      obj.friendlyMessage = message.friendlyMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpPlanOutput>, I>>(base?: I): OpPlanOutput {
    return OpPlanOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpPlanOutput>, I>>(object: I): OpPlanOutput {
    const message = createBaseOpPlanOutput();
    message.opDefinition = object.opDefinition ?? "";
    message.writesOutputs = object.writesOutputs?.map((e) => e) || [];
    message.friendlyMessage = object.friendlyMessage ?? "";
    return message;
  },
};

function createBasePlanResponse(): PlanResponse {
  return { ops: [] };
}

export const PlanResponse: MessageFns<PlanResponse> = {
  encode(message: PlanResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ops) {
      OpPlanOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ops.push(OpPlanOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlanResponse {
    return { ops: globalThis.Array.isArray(object?.ops) ? object.ops.map((e: any) => OpPlanOutput.fromJSON(e)) : [] };
  },

  toJSON(message: PlanResponse): unknown {
    const obj: any = {};
    if (message.ops?.length) {
      obj.ops = message.ops.map((e) => OpPlanOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlanResponse>, I>>(base?: I): PlanResponse {
    return PlanResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlanResponse>, I>>(object: I): PlanResponse {
    const message = createBasePlanResponse();
    message.ops = object.ops?.map((e) => OpPlanOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOpExecRequest(): OpExecRequest {
  return { addr: "", op: "" };
}

export const OpExecRequest: MessageFns<OpExecRequest> = {
  encode(message: OpExecRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.op !== "") {
      writer.uint32(18).string(message.op);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpExecRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpExecRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.op = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpExecRequest {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      op: isSet(object.op) ? globalThis.String(object.op) : "",
    };
  },

  toJSON(message: OpExecRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.op !== "") {
      obj.op = message.op;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpExecRequest>, I>>(base?: I): OpExecRequest {
    return OpExecRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpExecRequest>, I>>(object: I): OpExecRequest {
    const message = createBaseOpExecRequest();
    message.addr = object.addr ?? "";
    message.op = object.op ?? "";
    return message;
  },
};

function createBaseOpExecResponse(): OpExecResponse {
  return { outputs: {}, friendlyMessage: "" };
}

export const OpExecResponse: MessageFns<OpExecResponse> = {
  encode(message: OpExecResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.outputs).forEach(([key, value]) => {
      OpExecResponse_OutputsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.friendlyMessage !== "") {
      writer.uint32(18).string(message.friendlyMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpExecResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpExecResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = OpExecResponse_OutputsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.outputs[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.friendlyMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpExecResponse {
    return {
      outputs: isObject(object.outputs)
        ? Object.entries(object.outputs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      friendlyMessage: isSet(object.friendlyMessage) ? globalThis.String(object.friendlyMessage) : "",
    };
  },

  toJSON(message: OpExecResponse): unknown {
    const obj: any = {};
    if (message.outputs) {
      const entries = Object.entries(message.outputs);
      if (entries.length > 0) {
        obj.outputs = {};
        entries.forEach(([k, v]) => {
          obj.outputs[k] = v;
        });
      }
    }
    if (message.friendlyMessage !== "") {
      obj.friendlyMessage = message.friendlyMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpExecResponse>, I>>(base?: I): OpExecResponse {
    return OpExecResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpExecResponse>, I>>(object: I): OpExecResponse {
    const message = createBaseOpExecResponse();
    message.outputs = Object.entries(object.outputs ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.friendlyMessage = object.friendlyMessage ?? "";
    return message;
  },
};

function createBaseOpExecResponse_OutputsEntry(): OpExecResponse_OutputsEntry {
  return { key: "", value: "" };
}

export const OpExecResponse_OutputsEntry: MessageFns<OpExecResponse_OutputsEntry> = {
  encode(message: OpExecResponse_OutputsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpExecResponse_OutputsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpExecResponse_OutputsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpExecResponse_OutputsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OpExecResponse_OutputsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpExecResponse_OutputsEntry>, I>>(base?: I): OpExecResponse_OutputsEntry {
    return OpExecResponse_OutputsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpExecResponse_OutputsEntry>, I>>(object: I): OpExecResponse_OutputsEntry {
    const message = createBaseOpExecResponse_OutputsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAddrRequest(): AddrRequest {
  return { addr: "" };
}

export const AddrRequest: MessageFns<AddrRequest> = {
  encode(message: AddrRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddrRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddrRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddrRequest {
    return { addr: isSet(object.addr) ? globalThis.String(object.addr) : "" };
  },

  toJSON(message: AddrRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddrRequest>, I>>(base?: I): AddrRequest {
    return AddrRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddrRequest>, I>>(object: I): AddrRequest {
    const message = createBaseAddrRequest();
    message.addr = object.addr ?? "";
    return message;
  },
};

function createBaseAddrPhyToVirtResponse(): AddrPhyToVirtResponse {
  return { hasVirt: false, virtAddr: "" };
}

export const AddrPhyToVirtResponse: MessageFns<AddrPhyToVirtResponse> = {
  encode(message: AddrPhyToVirtResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasVirt !== false) {
      writer.uint32(8).bool(message.hasVirt);
    }
    if (message.virtAddr !== "") {
      writer.uint32(18).string(message.virtAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddrPhyToVirtResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddrPhyToVirtResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasVirt = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.virtAddr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddrPhyToVirtResponse {
    return {
      hasVirt: isSet(object.hasVirt) ? globalThis.Boolean(object.hasVirt) : false,
      virtAddr: isSet(object.virtAddr) ? globalThis.String(object.virtAddr) : "",
    };
  },

  toJSON(message: AddrPhyToVirtResponse): unknown {
    const obj: any = {};
    if (message.hasVirt !== false) {
      obj.hasVirt = message.hasVirt;
    }
    if (message.virtAddr !== "") {
      obj.virtAddr = message.virtAddr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddrPhyToVirtResponse>, I>>(base?: I): AddrPhyToVirtResponse {
    return AddrPhyToVirtResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddrPhyToVirtResponse>, I>>(object: I): AddrPhyToVirtResponse {
    const message = createBaseAddrPhyToVirtResponse();
    message.hasVirt = object.hasVirt ?? false;
    message.virtAddr = object.virtAddr ?? "";
    return message;
  },
};

function createBaseSubpathsResponse(): SubpathsResponse {
  return { subpaths: [] };
}

export const SubpathsResponse: MessageFns<SubpathsResponse> = {
  encode(message: SubpathsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subpaths) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubpathsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubpathsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subpaths.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubpathsResponse {
    return {
      subpaths: globalThis.Array.isArray(object?.subpaths) ? object.subpaths.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SubpathsResponse): unknown {
    const obj: any = {};
    if (message.subpaths?.length) {
      obj.subpaths = message.subpaths;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubpathsResponse>, I>>(base?: I): SubpathsResponse {
    return SubpathsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubpathsResponse>, I>>(object: I): SubpathsResponse {
    const message = createBaseSubpathsResponse();
    message.subpaths = object.subpaths?.map((e) => e) || [];
    return message;
  },
};

function createBaseSkeletonOutput(): SkeletonOutput {
  return { addr: "", body: new Uint8Array(0) };
}

export const SkeletonOutput: MessageFns<SkeletonOutput> = {
  encode(message: SkeletonOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkeletonOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkeletonOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkeletonOutput {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
    };
  },

  toJSON(message: SkeletonOutput): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkeletonOutput>, I>>(base?: I): SkeletonOutput {
    return SkeletonOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkeletonOutput>, I>>(object: I): SkeletonOutput {
    const message = createBaseSkeletonOutput();
    message.addr = object.addr ?? "";
    message.body = object.body ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetSkeletonsResponse(): GetSkeletonsResponse {
  return { skeletons: [] };
}

export const GetSkeletonsResponse: MessageFns<GetSkeletonsResponse> = {
  encode(message: GetSkeletonsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skeletons) {
      SkeletonOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSkeletonsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSkeletonsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skeletons.push(SkeletonOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSkeletonsResponse {
    return {
      skeletons: globalThis.Array.isArray(object?.skeletons)
        ? object.skeletons.map((e: any) => SkeletonOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSkeletonsResponse): unknown {
    const obj: any = {};
    if (message.skeletons?.length) {
      obj.skeletons = message.skeletons.map((e) => SkeletonOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSkeletonsResponse>, I>>(base?: I): GetSkeletonsResponse {
    return GetSkeletonsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSkeletonsResponse>, I>>(object: I): GetSkeletonsResponse {
    const message = createBaseGetSkeletonsResponse();
    message.skeletons = object.skeletons?.map((e) => SkeletonOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructIdent(): StructIdent {
  return { name: "" };
}

export const StructIdent: MessageFns<StructIdent> = {
  encode(message: StructIdent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructIdent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructIdent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructIdent {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StructIdent): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StructIdent>, I>>(base?: I): StructIdent {
    return StructIdent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StructIdent>, I>>(object: I): StructIdent {
    const message = createBaseStructIdent();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseFieldIdent(): FieldIdent {
  return { parent: "", name: "" };
}

export const FieldIdent: MessageFns<FieldIdent> = {
  encode(message: FieldIdent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldIdent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldIdent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldIdent {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: FieldIdent): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldIdent>, I>>(base?: I): FieldIdent {
    return FieldIdent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldIdent>, I>>(object: I): FieldIdent {
    const message = createBaseFieldIdent();
    message.parent = object.parent ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDocIdent(): DocIdent {
  return { struct: undefined, field: undefined };
}

export const DocIdent: MessageFns<DocIdent> = {
  encode(message: DocIdent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.struct !== undefined) {
      StructIdent.encode(message.struct, writer.uint32(10).fork()).join();
    }
    if (message.field !== undefined) {
      FieldIdent.encode(message.field, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocIdent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocIdent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.struct = StructIdent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.field = FieldIdent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocIdent {
    return {
      struct: isSet(object.struct) ? StructIdent.fromJSON(object.struct) : undefined,
      field: isSet(object.field) ? FieldIdent.fromJSON(object.field) : undefined,
    };
  },

  toJSON(message: DocIdent): unknown {
    const obj: any = {};
    if (message.struct !== undefined) {
      obj.struct = StructIdent.toJSON(message.struct);
    }
    if (message.field !== undefined) {
      obj.field = FieldIdent.toJSON(message.field);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocIdent>, I>>(base?: I): DocIdent {
    return DocIdent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocIdent>, I>>(object: I): DocIdent {
    const message = createBaseDocIdent();
    message.struct = (object.struct !== undefined && object.struct !== null)
      ? StructIdent.fromPartial(object.struct)
      : undefined;
    message.field = (object.field !== undefined && object.field !== null)
      ? FieldIdent.fromPartial(object.field)
      : undefined;
    return message;
  },
};

function createBaseGetDocRequest(): GetDocRequest {
  return { addr: "", ident: undefined };
}

export const GetDocRequest: MessageFns<GetDocRequest> = {
  encode(message: GetDocRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.ident !== undefined) {
      DocIdent.encode(message.ident, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ident = DocIdent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocRequest {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      ident: isSet(object.ident) ? DocIdent.fromJSON(object.ident) : undefined,
    };
  },

  toJSON(message: GetDocRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.ident !== undefined) {
      obj.ident = DocIdent.toJSON(message.ident);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDocRequest>, I>>(base?: I): GetDocRequest {
    return GetDocRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDocRequest>, I>>(object: I): GetDocRequest {
    const message = createBaseGetDocRequest();
    message.addr = object.addr ?? "";
    message.ident = (object.ident !== undefined && object.ident !== null)
      ? DocIdent.fromPartial(object.ident)
      : undefined;
    return message;
  },
};

function createBaseGetDocResponse(): GetDocResponse {
  return { hasDoc: false, markdown: "" };
}

export const GetDocResponse: MessageFns<GetDocResponse> = {
  encode(message: GetDocResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasDoc !== false) {
      writer.uint32(8).bool(message.hasDoc);
    }
    if (message.markdown !== "") {
      writer.uint32(18).string(message.markdown);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasDoc = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.markdown = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocResponse {
    return {
      hasDoc: isSet(object.hasDoc) ? globalThis.Boolean(object.hasDoc) : false,
      markdown: isSet(object.markdown) ? globalThis.String(object.markdown) : "",
    };
  },

  toJSON(message: GetDocResponse): unknown {
    const obj: any = {};
    if (message.hasDoc !== false) {
      obj.hasDoc = message.hasDoc;
    }
    if (message.markdown !== "") {
      obj.markdown = message.markdown;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDocResponse>, I>>(base?: I): GetDocResponse {
    return GetDocResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDocResponse>, I>>(object: I): GetDocResponse {
    const message = createBaseGetDocResponse();
    message.hasDoc = object.hasDoc ?? false;
    message.markdown = object.markdown ?? "";
    return message;
  },
};

function createBaseEqRequest(): EqRequest {
  return { addr: "", a: new Uint8Array(0), b: new Uint8Array(0) };
}

export const EqRequest: MessageFns<EqRequest> = {
  encode(message: EqRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.a.length !== 0) {
      writer.uint32(18).bytes(message.a);
    }
    if (message.b.length !== 0) {
      writer.uint32(26).bytes(message.b);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EqRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEqRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.a = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.b = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EqRequest {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      a: isSet(object.a) ? bytesFromBase64(object.a) : new Uint8Array(0),
      b: isSet(object.b) ? bytesFromBase64(object.b) : new Uint8Array(0),
    };
  },

  toJSON(message: EqRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.a.length !== 0) {
      obj.a = base64FromBytes(message.a);
    }
    if (message.b.length !== 0) {
      obj.b = base64FromBytes(message.b);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EqRequest>, I>>(base?: I): EqRequest {
    return EqRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EqRequest>, I>>(object: I): EqRequest {
    const message = createBaseEqRequest();
    message.addr = object.addr ?? "";
    message.a = object.a ?? new Uint8Array(0);
    message.b = object.b ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEqResponse(): EqResponse {
  return { equal: false };
}

export const EqResponse: MessageFns<EqResponse> = {
  encode(message: EqResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.equal !== false) {
      writer.uint32(8).bool(message.equal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EqResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEqResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.equal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EqResponse {
    return { equal: isSet(object.equal) ? globalThis.Boolean(object.equal) : false };
  },

  toJSON(message: EqResponse): unknown {
    const obj: any = {};
    if (message.equal !== false) {
      obj.equal = message.equal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EqResponse>, I>>(base?: I): EqResponse {
    return EqResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EqResponse>, I>>(object: I): EqResponse {
    const message = createBaseEqResponse();
    message.equal = object.equal ?? false;
    return message;
  },
};

function createBaseDiagnosticPosition(): DiagnosticPosition {
  return { line: 0, col: 0 };
}

export const DiagnosticPosition: MessageFns<DiagnosticPosition> = {
  encode(message: DiagnosticPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line !== 0) {
      writer.uint32(8).uint32(message.line);
    }
    if (message.col !== 0) {
      writer.uint32(16).uint32(message.col);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnosticPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnosticPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.line = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.col = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnosticPosition {
    return {
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      col: isSet(object.col) ? globalThis.Number(object.col) : 0,
    };
  },

  toJSON(message: DiagnosticPosition): unknown {
    const obj: any = {};
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.col !== 0) {
      obj.col = Math.round(message.col);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagnosticPosition>, I>>(base?: I): DiagnosticPosition {
    return DiagnosticPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagnosticPosition>, I>>(object: I): DiagnosticPosition {
    const message = createBaseDiagnosticPosition();
    message.line = object.line ?? 0;
    message.col = object.col ?? 0;
    return message;
  },
};

function createBaseDiagnosticSpan(): DiagnosticSpan {
  return { start: undefined, end: undefined };
}

export const DiagnosticSpan: MessageFns<DiagnosticSpan> = {
  encode(message: DiagnosticSpan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      DiagnosticPosition.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      DiagnosticPosition.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnosticSpan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnosticSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.start = DiagnosticPosition.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.end = DiagnosticPosition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnosticSpan {
    return {
      start: isSet(object.start) ? DiagnosticPosition.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? DiagnosticPosition.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: DiagnosticSpan): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = DiagnosticPosition.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = DiagnosticPosition.toJSON(message.end);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagnosticSpan>, I>>(base?: I): DiagnosticSpan {
    return DiagnosticSpan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagnosticSpan>, I>>(object: I): DiagnosticSpan {
    const message = createBaseDiagnosticSpan();
    message.start = (object.start !== undefined && object.start !== null)
      ? DiagnosticPosition.fromPartial(object.start)
      : undefined;
    message.end = (object.end !== undefined && object.end !== null)
      ? DiagnosticPosition.fromPartial(object.end)
      : undefined;
    return message;
  },
};

function createBaseDiagnostic(): Diagnostic {
  return { severity: 0, span: undefined, message: "" };
}

export const Diagnostic: MessageFns<Diagnostic> = {
  encode(message: Diagnostic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severity !== 0) {
      writer.uint32(8).uint32(message.severity);
    }
    if (message.span !== undefined) {
      DiagnosticSpan.encode(message.span, writer.uint32(18).fork()).join();
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Diagnostic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnostic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.severity = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.span = DiagnosticSpan.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Diagnostic {
    return {
      severity: isSet(object.severity) ? globalThis.Number(object.severity) : 0,
      span: isSet(object.span) ? DiagnosticSpan.fromJSON(object.span) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Diagnostic): unknown {
    const obj: any = {};
    if (message.severity !== 0) {
      obj.severity = Math.round(message.severity);
    }
    if (message.span !== undefined) {
      obj.span = DiagnosticSpan.toJSON(message.span);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Diagnostic>, I>>(base?: I): Diagnostic {
    return Diagnostic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Diagnostic>, I>>(object: I): Diagnostic {
    const message = createBaseDiagnostic();
    message.severity = object.severity ?? 0;
    message.span = (object.span !== undefined && object.span !== null)
      ? DiagnosticSpan.fromPartial(object.span)
      : undefined;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseDiagnosticOutput(): DiagnosticOutput {
  return { diagnostics: [] };
}

export const DiagnosticOutput: MessageFns<DiagnosticOutput> = {
  encode(message: DiagnosticOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.diagnostics) {
      Diagnostic.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagnosticOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagnosticOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diagnostics.push(Diagnostic.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagnosticOutput {
    return {
      diagnostics: globalThis.Array.isArray(object?.diagnostics)
        ? object.diagnostics.map((e: any) => Diagnostic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DiagnosticOutput): unknown {
    const obj: any = {};
    if (message.diagnostics?.length) {
      obj.diagnostics = message.diagnostics.map((e) => Diagnostic.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagnosticOutput>, I>>(base?: I): DiagnosticOutput {
    return DiagnosticOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagnosticOutput>, I>>(object: I): DiagnosticOutput {
    const message = createBaseDiagnosticOutput();
    message.diagnostics = object.diagnostics?.map((e) => Diagnostic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiagRequest(): DiagRequest {
  return { addr: "", a: new Uint8Array(0) };
}

export const DiagRequest: MessageFns<DiagRequest> = {
  encode(message: DiagRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.a.length !== 0) {
      writer.uint32(18).bytes(message.a);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.a = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagRequest {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      a: isSet(object.a) ? bytesFromBase64(object.a) : new Uint8Array(0),
    };
  },

  toJSON(message: DiagRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.a.length !== 0) {
      obj.a = base64FromBytes(message.a);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagRequest>, I>>(base?: I): DiagRequest {
    return DiagRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagRequest>, I>>(object: I): DiagRequest {
    const message = createBaseDiagRequest();
    message.addr = object.addr ?? "";
    message.a = object.a ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDiagResponse(): DiagResponse {
  return { diagnostics: undefined };
}

export const DiagResponse: MessageFns<DiagResponse> = {
  encode(message: DiagResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diagnostics !== undefined) {
      DiagnosticOutput.encode(message.diagnostics, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiagResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiagResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diagnostics = DiagnosticOutput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiagResponse {
    return { diagnostics: isSet(object.diagnostics) ? DiagnosticOutput.fromJSON(object.diagnostics) : undefined };
  },

  toJSON(message: DiagResponse): unknown {
    const obj: any = {};
    if (message.diagnostics !== undefined) {
      obj.diagnostics = DiagnosticOutput.toJSON(message.diagnostics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiagResponse>, I>>(base?: I): DiagResponse {
    return DiagResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiagResponse>, I>>(object: I): DiagResponse {
    const message = createBaseDiagResponse();
    message.diagnostics = (object.diagnostics !== undefined && object.diagnostics !== null)
      ? DiagnosticOutput.fromPartial(object.diagnostics)
      : undefined;
    return message;
  },
};

function createBaseReadOutput(): ReadOutput {
  return { addr: "", key: "" };
}

export const ReadOutput: MessageFns<ReadOutput> = {
  encode(message: ReadOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadOutput {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: ReadOutput): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadOutput>, I>>(base?: I): ReadOutput {
    return ReadOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadOutput>, I>>(object: I): ReadOutput {
    const message = createBaseReadOutput();
    message.addr = object.addr ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseDeferred(): Deferred {
  return { reads: [] };
}

export const Deferred: MessageFns<Deferred> = {
  encode(message: Deferred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reads) {
      ReadOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deferred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reads.push(ReadOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deferred {
    return {
      reads: globalThis.Array.isArray(object?.reads) ? object.reads.map((e: any) => ReadOutput.fromJSON(e)) : [],
    };
  },

  toJSON(message: Deferred): unknown {
    const obj: any = {};
    if (message.reads?.length) {
      obj.reads = message.reads.map((e) => ReadOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Deferred>, I>>(base?: I): Deferred {
    return Deferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Deferred>, I>>(object: I): Deferred {
    const message = createBaseDeferred();
    message.reads = object.reads?.map((e) => ReadOutput.fromPartial(e)) || [];
    return message;
  },
};

function createBasePath(): Path {
  return { path: "" };
}

export const Path: MessageFns<Path> = {
  encode(message: Path, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Path {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Path {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: Path): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Path>, I>>(base?: I): Path {
    return Path.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Path>, I>>(object: I): Path {
    const message = createBasePath();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseVirtToPhyOutput(): VirtToPhyOutput {
  return { notPresent: undefined, deferred: undefined, present: undefined, null: undefined };
}

export const VirtToPhyOutput: MessageFns<VirtToPhyOutput> = {
  encode(message: VirtToPhyOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notPresent !== undefined) {
      Empty.encode(message.notPresent, writer.uint32(10).fork()).join();
    }
    if (message.deferred !== undefined) {
      Deferred.encode(message.deferred, writer.uint32(18).fork()).join();
    }
    if (message.present !== undefined) {
      Path.encode(message.present, writer.uint32(26).fork()).join();
    }
    if (message.null !== undefined) {
      Path.encode(message.null, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtToPhyOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtToPhyOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notPresent = Empty.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deferred = Deferred.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.present = Path.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.null = Path.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VirtToPhyOutput {
    return {
      notPresent: isSet(object.notPresent) ? Empty.fromJSON(object.notPresent) : undefined,
      deferred: isSet(object.deferred) ? Deferred.fromJSON(object.deferred) : undefined,
      present: isSet(object.present) ? Path.fromJSON(object.present) : undefined,
      null: isSet(object.null) ? Path.fromJSON(object.null) : undefined,
    };
  },

  toJSON(message: VirtToPhyOutput): unknown {
    const obj: any = {};
    if (message.notPresent !== undefined) {
      obj.notPresent = Empty.toJSON(message.notPresent);
    }
    if (message.deferred !== undefined) {
      obj.deferred = Deferred.toJSON(message.deferred);
    }
    if (message.present !== undefined) {
      obj.present = Path.toJSON(message.present);
    }
    if (message.null !== undefined) {
      obj.null = Path.toJSON(message.null);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VirtToPhyOutput>, I>>(base?: I): VirtToPhyOutput {
    return VirtToPhyOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VirtToPhyOutput>, I>>(object: I): VirtToPhyOutput {
    const message = createBaseVirtToPhyOutput();
    message.notPresent = (object.notPresent !== undefined && object.notPresent !== null)
      ? Empty.fromPartial(object.notPresent)
      : undefined;
    message.deferred = (object.deferred !== undefined && object.deferred !== null)
      ? Deferred.fromPartial(object.deferred)
      : undefined;
    message.present = (object.present !== undefined && object.present !== null)
      ? Path.fromPartial(object.present)
      : undefined;
    message.null = (object.null !== undefined && object.null !== null) ? Path.fromPartial(object.null) : undefined;
    return message;
  },
};

function createBaseUnbundleRequest(): UnbundleRequest {
  return { addr: "", bundle: new Uint8Array(0) };
}

export const UnbundleRequest: MessageFns<UnbundleRequest> = {
  encode(message: UnbundleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addr !== "") {
      writer.uint32(10).string(message.addr);
    }
    if (message.bundle.length !== 0) {
      writer.uint32(18).bytes(message.bundle);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbundleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbundleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bundle = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnbundleRequest {
    return {
      addr: isSet(object.addr) ? globalThis.String(object.addr) : "",
      bundle: isSet(object.bundle) ? bytesFromBase64(object.bundle) : new Uint8Array(0),
    };
  },

  toJSON(message: UnbundleRequest): unknown {
    const obj: any = {};
    if (message.addr !== "") {
      obj.addr = message.addr;
    }
    if (message.bundle.length !== 0) {
      obj.bundle = base64FromBytes(message.bundle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnbundleRequest>, I>>(base?: I): UnbundleRequest {
    return UnbundleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnbundleRequest>, I>>(object: I): UnbundleRequest {
    const message = createBaseUnbundleRequest();
    message.addr = object.addr ?? "";
    message.bundle = object.bundle ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBundleOutput(): BundleOutput {
  return { filename: "", fileContents: "" };
}

export const BundleOutput: MessageFns<BundleOutput> = {
  encode(message: BundleOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filename !== "") {
      writer.uint32(10).string(message.filename);
    }
    if (message.fileContents !== "") {
      writer.uint32(18).string(message.fileContents);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BundleOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBundleOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileContents = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BundleOutput {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      fileContents: isSet(object.fileContents) ? globalThis.String(object.fileContents) : "",
    };
  },

  toJSON(message: BundleOutput): unknown {
    const obj: any = {};
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.fileContents !== "") {
      obj.fileContents = message.fileContents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BundleOutput>, I>>(base?: I): BundleOutput {
    return BundleOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BundleOutput>, I>>(object: I): BundleOutput {
    const message = createBaseBundleOutput();
    message.filename = object.filename ?? "";
    message.fileContents = object.fileContents ?? "";
    return message;
  },
};

function createBaseUnbundleResponse(): UnbundleResponse {
  return { bundles: [] };
}

export const UnbundleResponse: MessageFns<UnbundleResponse> = {
  encode(message: UnbundleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bundles) {
      BundleOutput.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbundleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbundleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bundles.push(BundleOutput.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnbundleResponse {
    return {
      bundles: globalThis.Array.isArray(object?.bundles)
        ? object.bundles.map((e: any) => BundleOutput.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UnbundleResponse): unknown {
    const obj: any = {};
    if (message.bundles?.length) {
      obj.bundles = message.bundles.map((e) => BundleOutput.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnbundleResponse>, I>>(base?: I): UnbundleResponse {
    return UnbundleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnbundleResponse>, I>>(object: I): UnbundleResponse {
    const message = createBaseUnbundleResponse();
    message.bundles = object.bundles?.map((e) => BundleOutput.fromPartial(e)) || [];
    return message;
  },
};

/** / --- The Connector gRPC service --- */
export type ConnectorService = typeof ConnectorService;
export const ConnectorService = {
  init: {
    path: "/connector.Connector/Init",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  filter: {
    path: "/connector.Connector/Filter",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FilterRequest): Buffer => Buffer.from(FilterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FilterRequest => FilterRequest.decode(value),
    responseSerialize: (value: FilterResponse): Buffer => Buffer.from(FilterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): FilterResponse => FilterResponse.decode(value),
  },
  list: {
    path: "/connector.Connector/List",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRequest): Buffer => Buffer.from(ListRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRequest => ListRequest.decode(value),
    responseSerialize: (value: ListResponse): Buffer => Buffer.from(ListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListResponse => ListResponse.decode(value),
  },
  subpaths: {
    path: "/connector.Connector/Subpaths",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: SubpathsResponse): Buffer => Buffer.from(SubpathsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SubpathsResponse => SubpathsResponse.decode(value),
  },
  get: {
    path: "/connector.Connector/Get",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRequest): Buffer => Buffer.from(GetRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRequest => GetRequest.decode(value),
    responseSerialize: (value: GetResponse): Buffer => Buffer.from(GetResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetResponse => GetResponse.decode(value),
  },
  plan: {
    path: "/connector.Connector/Plan",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PlanRequest): Buffer => Buffer.from(PlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PlanRequest => PlanRequest.decode(value),
    responseSerialize: (value: PlanResponse): Buffer => Buffer.from(PlanResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PlanResponse => PlanResponse.decode(value),
  },
  opExec: {
    path: "/connector.Connector/OpExec",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: OpExecRequest): Buffer => Buffer.from(OpExecRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): OpExecRequest => OpExecRequest.decode(value),
    responseSerialize: (value: OpExecResponse): Buffer => Buffer.from(OpExecResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): OpExecResponse => OpExecResponse.decode(value),
  },
  addrVirtToPhy: {
    path: "/connector.Connector/AddrVirtToPhy",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddrRequest): Buffer => Buffer.from(AddrRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddrRequest => AddrRequest.decode(value),
    responseSerialize: (value: VirtToPhyOutput): Buffer => Buffer.from(VirtToPhyOutput.encode(value).finish()),
    responseDeserialize: (value: Buffer): VirtToPhyOutput => VirtToPhyOutput.decode(value),
  },
  addrPhyToVirt: {
    path: "/connector.Connector/AddrPhyToVirt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddrRequest): Buffer => Buffer.from(AddrRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): AddrRequest => AddrRequest.decode(value),
    responseSerialize: (value: AddrPhyToVirtResponse): Buffer =>
      Buffer.from(AddrPhyToVirtResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AddrPhyToVirtResponse => AddrPhyToVirtResponse.decode(value),
  },
  getSkeletons: {
    path: "/connector.Connector/GetSkeletons",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: GetSkeletonsResponse): Buffer =>
      Buffer.from(GetSkeletonsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetSkeletonsResponse => GetSkeletonsResponse.decode(value),
  },
  getDocstring: {
    path: "/connector.Connector/GetDocstring",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetDocRequest): Buffer => Buffer.from(GetDocRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetDocRequest => GetDocRequest.decode(value),
    responseSerialize: (value: GetDocResponse): Buffer => Buffer.from(GetDocResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetDocResponse => GetDocResponse.decode(value),
  },
  eq: {
    path: "/connector.Connector/Eq",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EqRequest): Buffer => Buffer.from(EqRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EqRequest => EqRequest.decode(value),
    responseSerialize: (value: EqResponse): Buffer => Buffer.from(EqResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EqResponse => EqResponse.decode(value),
  },
  diag: {
    path: "/connector.Connector/Diag",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DiagRequest): Buffer => Buffer.from(DiagRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DiagRequest => DiagRequest.decode(value),
    responseSerialize: (value: DiagResponse): Buffer => Buffer.from(DiagResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DiagResponse => DiagResponse.decode(value),
  },
  unbundle: {
    path: "/connector.Connector/Unbundle",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnbundleRequest): Buffer => Buffer.from(UnbundleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UnbundleRequest => UnbundleRequest.decode(value),
    responseSerialize: (value: UnbundleResponse): Buffer => Buffer.from(UnbundleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UnbundleResponse => UnbundleResponse.decode(value),
  },
} as const;

export interface ConnectorServer extends UntypedServiceImplementation {
  init: handleUnaryCall<Empty, Empty>;
  filter: handleUnaryCall<FilterRequest, FilterResponse>;
  list: handleUnaryCall<ListRequest, ListResponse>;
  subpaths: handleUnaryCall<Empty, SubpathsResponse>;
  get: handleUnaryCall<GetRequest, GetResponse>;
  plan: handleUnaryCall<PlanRequest, PlanResponse>;
  opExec: handleUnaryCall<OpExecRequest, OpExecResponse>;
  addrVirtToPhy: handleUnaryCall<AddrRequest, VirtToPhyOutput>;
  addrPhyToVirt: handleUnaryCall<AddrRequest, AddrPhyToVirtResponse>;
  getSkeletons: handleUnaryCall<Empty, GetSkeletonsResponse>;
  getDocstring: handleUnaryCall<GetDocRequest, GetDocResponse>;
  eq: handleUnaryCall<EqRequest, EqResponse>;
  diag: handleUnaryCall<DiagRequest, DiagResponse>;
  unbundle: handleUnaryCall<UnbundleRequest, UnbundleResponse>;
}

export interface ConnectorClient extends Client {
  init(request: Empty, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  init(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  init(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  filter(
    request: FilterRequest,
    callback: (error: ServiceError | null, response: FilterResponse) => void,
  ): ClientUnaryCall;
  filter(
    request: FilterRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: FilterResponse) => void,
  ): ClientUnaryCall;
  filter(
    request: FilterRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: FilterResponse) => void,
  ): ClientUnaryCall;
  list(request: ListRequest, callback: (error: ServiceError | null, response: ListResponse) => void): ClientUnaryCall;
  list(
    request: ListRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListResponse) => void,
  ): ClientUnaryCall;
  list(
    request: ListRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListResponse) => void,
  ): ClientUnaryCall;
  subpaths(request: Empty, callback: (error: ServiceError | null, response: SubpathsResponse) => void): ClientUnaryCall;
  subpaths(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SubpathsResponse) => void,
  ): ClientUnaryCall;
  subpaths(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SubpathsResponse) => void,
  ): ClientUnaryCall;
  get(request: GetRequest, callback: (error: ServiceError | null, response: GetResponse) => void): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  get(
    request: GetRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetResponse) => void,
  ): ClientUnaryCall;
  plan(request: PlanRequest, callback: (error: ServiceError | null, response: PlanResponse) => void): ClientUnaryCall;
  plan(
    request: PlanRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PlanResponse) => void,
  ): ClientUnaryCall;
  plan(
    request: PlanRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PlanResponse) => void,
  ): ClientUnaryCall;
  opExec(
    request: OpExecRequest,
    callback: (error: ServiceError | null, response: OpExecResponse) => void,
  ): ClientUnaryCall;
  opExec(
    request: OpExecRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: OpExecResponse) => void,
  ): ClientUnaryCall;
  opExec(
    request: OpExecRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: OpExecResponse) => void,
  ): ClientUnaryCall;
  addrVirtToPhy(
    request: AddrRequest,
    callback: (error: ServiceError | null, response: VirtToPhyOutput) => void,
  ): ClientUnaryCall;
  addrVirtToPhy(
    request: AddrRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VirtToPhyOutput) => void,
  ): ClientUnaryCall;
  addrVirtToPhy(
    request: AddrRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VirtToPhyOutput) => void,
  ): ClientUnaryCall;
  addrPhyToVirt(
    request: AddrRequest,
    callback: (error: ServiceError | null, response: AddrPhyToVirtResponse) => void,
  ): ClientUnaryCall;
  addrPhyToVirt(
    request: AddrRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AddrPhyToVirtResponse) => void,
  ): ClientUnaryCall;
  addrPhyToVirt(
    request: AddrRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AddrPhyToVirtResponse) => void,
  ): ClientUnaryCall;
  getSkeletons(
    request: Empty,
    callback: (error: ServiceError | null, response: GetSkeletonsResponse) => void,
  ): ClientUnaryCall;
  getSkeletons(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSkeletonsResponse) => void,
  ): ClientUnaryCall;
  getSkeletons(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSkeletonsResponse) => void,
  ): ClientUnaryCall;
  getDocstring(
    request: GetDocRequest,
    callback: (error: ServiceError | null, response: GetDocResponse) => void,
  ): ClientUnaryCall;
  getDocstring(
    request: GetDocRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetDocResponse) => void,
  ): ClientUnaryCall;
  getDocstring(
    request: GetDocRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetDocResponse) => void,
  ): ClientUnaryCall;
  eq(request: EqRequest, callback: (error: ServiceError | null, response: EqResponse) => void): ClientUnaryCall;
  eq(
    request: EqRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EqResponse) => void,
  ): ClientUnaryCall;
  eq(
    request: EqRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EqResponse) => void,
  ): ClientUnaryCall;
  diag(request: DiagRequest, callback: (error: ServiceError | null, response: DiagResponse) => void): ClientUnaryCall;
  diag(
    request: DiagRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DiagResponse) => void,
  ): ClientUnaryCall;
  diag(
    request: DiagRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DiagResponse) => void,
  ): ClientUnaryCall;
  unbundle(
    request: UnbundleRequest,
    callback: (error: ServiceError | null, response: UnbundleResponse) => void,
  ): ClientUnaryCall;
  unbundle(
    request: UnbundleRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UnbundleResponse) => void,
  ): ClientUnaryCall;
  unbundle(
    request: UnbundleRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UnbundleResponse) => void,
  ): ClientUnaryCall;
}

export const ConnectorClient = makeGenericClientConstructor(ConnectorService, "connector.Connector") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ConnectorClient;
  service: typeof ConnectorService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
